// Generated by LiveScript 1.2.0
(function(){
  var child_process, fs, _namespaces, _testUrl, _deleteAllRetries, _deleteAllDelay, slice$ = [].slice;
  child_process = require('child_process');
  fs = require('fs');
  import$(global, require('prelude-ls'));
  _namespaces = {};
  _testUrl = 'https://icanhazip.com';
  _deleteAllRetries = 5;
  _deleteAllDelay = 2000;
  function NetNS(ipAddress){
    var that;
    if (that = _namespaces[this.name]) {
      return that;
    }
    this.ipAddress = ipAddress;
    this.name = "ns" + ipAddress.replace(/\./g, '-');
    return _namespaces[this.name] = this;
  }
  NetNS.deleteAll = function(cb){
    var retries, pending, errors, retryDelete, cbi;
    retries = {};
    keys(function(ns){
      return retries[ns] = 0;
    })(
    _namespaces);
    pending = keys(
    retries).length;
    errors = [];
    retryDelete = function(nsName){
      var ns;
      ns = _namespaces[nsName];
      return ns['delete'](function(err){
        if (err) {
          console.error("error deleting namespace: " + ns.name + " with IP: " + ns.ipAddress, err);
          if (retries[nsName]++ < _deleteAllRetries) {
            return setTimeout(function(){
              return retryDelete(nsName);
            }, _deleteAllDelay);
          } else {
            errors.push(err);
            return pending--;
          }
        } else {
          return pending--;
        }
      });
    };
    keys(retryDelete)(
    _namespaces);
    return (cbi = partialize$.apply(this, [setInterval, [void 8, 1000], [0]]))(function(){
      var err;
      if (pending <= 0) {
        clearInterval(cbi);
        if (errors.length) {
          err = new Error('deletion error(s)');
          err.namespaces = errors;
          return cb(err);
        } else {
          return cb(void 8);
        }
      }
    });
  };
  NetNS.prototype.create = function(cb){
    var nameSuffix, last2Octets;
    if (!this._exists()) {
      nameSuffix = this.ipAddress.replace(/\./g, '-');
      last2Octets = this.ipAddress.replace(/^\d+\.\d+\./, '');
      return _execSeries(["ip netns add ns" + nameSuffix, "ip netns exec ns" + nameSuffix + " ip link set lo up", "ip link add d" + nameSuffix + " type veth peer name v" + nameSuffix, "ip link set up d" + nameSuffix, "ip link set v" + nameSuffix + " netns ns" + nameSuffix, "ip netns exec ns" + nameSuffix + " ip link set v" + nameSuffix + " up", "ip addr add 10." + last2Octets + ".0/31 dev d" + nameSuffix, "ip netns exec ns" + nameSuffix + " ip addr add 10." + last2Octets + ".1/31 dev v" + nameSuffix, "ip netns exec ns" + nameSuffix + " ip route add default via 10." + last2Octets + ".0", "iptables -t nat -A PREROUTING -d " + this.ipAddress + " -j DNAT --to 10." + last2Octets + ".1", "iptables -t nat -A POSTROUTING -s 10." + last2Octets + ".0/31 -j SNAT --to " + this.ipAddress], cb);
    } else {
      return cb(void 8);
    }
  };
  NetNS.prototype['delete'] = function(cb){
    var nameSuffix, last2Octets;
    if (this._exists()) {
      nameSuffix = this.ipAddress.replace(/\./g, '-');
      last2Octets = this.ipAddress.replace(/^\d+\.\d+\./, '');
      return _execSeries(["ip netns del ns" + nameSuffix, "ip link del d" + nameSuffix, "iptables -t nat -D PREROUTING -d " + this.ipAddress + " -j DNAT --to 10." + last2Octets + ".1", "iptables -t nat -D POSTROUTING -s 10." + last2Octets + ".0/31 -j SNAT --to " + this.ipAddress], cb);
    } else {
      return cb(void 8);
    }
  };
  NetNS.prototype._exists = function(){
    return fs.existsSync("/var/run/netns/" + this.name);
  };
  NetNS.prototype.test = function(cb){
    var cmd, dataBuf, errBuf, proc, x$, this$ = this;
    if (this._exists()) {
      cmd = "ip netns exec " + this.name + " curl " + _testUrl;
      dataBuf = errBuf = '';
      proc = child_process.exec(cmd);
      x$ = proc;
      x$.stdout.on('data', function(it){
        return dataBuf += it;
      });
      x$.stderr.on('data', function(it){
        return errBuf += it;
      });
      return proc.on('close', function(code){
        if (code !== 0) {
          return cb(new Error(errBuf));
        } else if (dataBuf !== this$.ipAddress + "\n") {
          return cb(new Error("IP mismatch: got: " + dataBuf + " but expected: " + this$.ipAddress + "\\n"));
        } else {
          return cb(void 8);
        }
      });
    } else {
      return cb(new Error("namespace doesn't seem to exist"));
    }
  };
  function _exec(cmd, cb){
    var parts, p;
    parts = cmd.split(/\s+/g);
    p = child_process.spawn(parts[0], parts.slice(1), {
      stdio: 'inherit'
    });
    return p.on('exit', function(code){
      var err;
      if (code) {
        err = new Error("command " + cmd + " exited with wrong status code " + code);
        err.code = code;
        err.cmd = cmd;
      }
      if (cb) {
        return cb(err);
      } else {
        return cb(void 8);
      }
    });
  }
  function _execSeries(cmds, cb){
    var execNext;
    execNext = function(){
      return _exec(cmds.shift(), function(err){
        if (err) {
          return cb(err);
        } else {
          if (cmds.length) {
            return execNext();
          } else {
            return cb(void 8);
          }
        }
      });
    };
    return execNext();
  }
  module.exports = NetNS;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function partialize$(f, args, where){
    var context = this;
    return function(){
      var params = slice$.call(arguments), i,
          len = params.length, wlen = where.length,
          ta = args ? args.concat() : [], tw = where ? where.concat() : [];
      for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
      return len < wlen && len ?
        partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);
    };
  }
}).call(this);
