// Generated by LiveScript 1.2.0
(function(){
  var child_process, fs, ip, async, _namespaces, _testUrl, _deleteAllRetries, _deleteAllDelay, _ports;
  child_process = require('child_process');
  fs = require('fs');
  ip = require('ip');
  async = require('async');
  import$(global, require('prelude-ls'));
  _namespaces = {};
  _testUrl = 'https://blender.instantchannelinc.com/ipecho-api/v1/';
  _deleteAllRetries = 5;
  _deleteAllDelay = 2000;
  function NetNS(ipAddress, preRouting){
    var that;
    this.ipAddress = ipAddress;
    this.preRouting = preRouting;
    this._long = ip.toLong(ipAddress);
    this.name = "ns" + this._long;
    this._verified = false;
    if (that = _namespaces[this.name]) {
      return that;
    }
    return _namespaces[this.name] = this;
  }
  NetNS.deleteAll = function(cb, retries){
    var pending;
    retries == null && (retries = _deleteAllRetries);
    pending = 0;
    return Obj.each(function(ns){
      var timer;
      pending++;
      ns['delete'](function(){
        return pending--;
      });
      return timer = setInterval(function(){
        var existing;
        if (!pending) {
          clearInterval(timer);
          existing = {};
          return async.each(_namespaces, function(ns, cb){
            return ns._exists(function(err, exists){
              if (exists) {
                existing[ns] = ns;
              }
              return cb(void 8);
            });
          }, function(err){
            var error;
            if (keys(existing).length) {
              if (retries) {
                return setTimeout(function(){
                  return NetNS.deleteAll(cb, retries - 1);
                }, _deleteAllDelay);
              } else {
                error = new Error("failed to delete some namespaces");
                error.namespaces = existing;
                if (cb) {
                  return cb(error);
                }
              }
            } else {
              if (cb) {
                return cb(void 8);
              }
            }
          });
        }
      }, 100);
    }, _namespaces);
  };
  NetNS.deleteList = function(list, cb, retries){
    var namespaces, pending;
    list == null && (list = []);
    retries == null && (retries = _deleteAllRetries);
    namespaces = function(){
      return filter(function(it){
        return in$(it.ipAddress, list);
      }, _namespaces);
    };
    pending = 0;
    return Obj.each(function(ns){
      var timer;
      pending++;
      ns['delete'](function(){
        return pending--;
      });
      return timer = setInterval(function(){
        var existing;
        if (!pending) {
          clearInterval(timer);
          existing = {};
          return async.each(namespaces(), function(ns, cb){
            return ns._exists(function(err, exists){
              if (exists) {
                existing[ns] = ns;
              }
              return cb(void 8);
            });
          }, function(err){
            var error;
            if (keys(existing).length) {
              if (retries) {
                return setTimeout(function(){
                  return NetNS.deleteList(list, cb, retries - 1);
                }, _deleteAllDelay);
              } else {
                error = new Error("failed to delete some namespaces");
                error.namespaces = existing;
                if (cb) {
                  return cb(error);
                }
              }
            } else {
              if (cb) {
                return cb(void 8);
              }
            }
          });
        }
      }, 100);
    }, namespaces());
  };
  NetNS.prototype.run = function(command, cb, opts){
    var defaultOpts, this$ = this;
    opts == null && (opts = {});
    defaultOpts = {
      verify: false,
      cleanup: false
    };
    opts = import$(defaultOpts, opts);
    return this.create(function(createErr){
      var run;
      if (createErr) {
        return this$['delete'](function(deleteErr){
          if (deleteErr) {
            createErr.deletionError = deleteErr;
            return cb(createErr);
          }
        });
      } else {
        run = function(){
          var nsWrap, nsProc;
          nsWrap = ("ip netns exec " + this$.name + " " + command).split(' ');
          nsProc = child_process.spawn(nsWrap[0], nsWrap.slice(1), {
            stdio: 'pipe'
          });
          if (opts.cleanup) {
            nsProc.on('exit', function(){
              return this$['delete'](function(){});
            });
          }
          return cb(void 8, nsProc);
        };
        if (!this$._verified && opts.verify) {
          return this$.test(function(testErr){
            if (testErr) {
              return cb(testErr);
            } else {
              return run();
            }
          });
        } else {
          return run();
        }
      }
    });
  };
  NetNS.prototype.create = function(cb){
    var this$ = this;
    return this._exists(function(err, exists){
      var nameSuffix, last2Octets, table, preRoutingExists, postRoutingExists, netnsExists, commands;
      if (err) {
        return cb(err);
      } else if (exists === false || exists === null) {
        nameSuffix = this$._long;
        last2Octets = this$.ipAddress.replace(/^\d+\.\d+\./, '');
        table = this$._getTable();
        preRoutingExists = this$._findRule(table, 'PRE');
        postRoutingExists = this$._findRule(table, 'POST');
        netnsExists = this$._netnsExists();
        commands = [];
        if (!netnsExists) {
          commands = commands.concat(["ip netns add ns" + nameSuffix, "ip netns exec ns" + nameSuffix + " ip link set lo up", "ip link add d" + nameSuffix + " type veth peer name v" + nameSuffix, "ip link set up d" + nameSuffix, "ip link set v" + nameSuffix + " netns ns" + nameSuffix, "ip netns exec ns" + nameSuffix + " ip link set v" + nameSuffix + " up", "ip addr add 10." + last2Octets + ".0/31 dev d" + nameSuffix, "ip netns exec ns" + nameSuffix + " ip addr add 10." + last2Octets + ".1/31 dev v" + nameSuffix, "ip netns exec ns" + nameSuffix + " ip route add default via 10." + last2Octets + ".0"]);
        }
        if (!(preRoutingExists && this$.preRouting)) {
          commands.push("iptables -t nat -A PREROUTING -d " + this$.ipAddress + " -j DNAT --to 10." + last2Octets + ".1");
        }
        if (!postRoutingExists) {
          commands.push("iptables -t nat -A POSTROUTING -s 10." + last2Octets + ".0/31 -j SNAT --to " + this$.ipAddress);
        }
        return async.eachSeries(commands, function(cmd, cb){
          return child_process.exec(cmd, function(err, stdout, stderr){
            if (err) {
              console.error('NetNS.create error: ', cmd, stderr);
              return cb(err);
            } else {
              return cb(void 8);
            }
          });
        }, function(err){
          if (err) {
            return cb(err);
          } else {
            return cb(void 8);
          }
        });
      } else {
        return cb(void 8);
      }
    });
  };
  NetNS.prototype['delete'] = function(cb){
    var this$ = this;
    return this._exists(function(err, exists){
      var nameSuffix, last2Octets;
      if (err) {
        return cb(err);
      } else if (exists === true || exists === null) {
        nameSuffix = this$._long;
        last2Octets = this$.ipAddress.replace(/^\d+\.\d+\./, '');
        return async.eachSeries(["ip netns del ns" + nameSuffix, "ip link del d" + nameSuffix, "iptables -t nat -D PREROUTING -d " + this$.ipAddress + "/32 -p tcp --match multiport --dports " + _ports.join(',') + " -j DNAT --to-destination 10." + last2Octets + ".1", "iptables -t nat -D POSTROUTING -s 10." + last2Octets + ".0/31 -j SNAT --to " + this$.ipAddress], function(cmd, cb){
          return child_process.exec(cmd, function(err, stdout, stderr){
            if (err) {
              console.error('NetNS.delete error: ', cmd, stderr);
              return cb(void 8);
            } else {
              return cb(void 8);
            }
          });
        }, function(err){
          if (err) {
            return cb(err);
          } else {
            return cb(void 8);
          }
        });
      } else {
        return cb(void 8);
      }
    });
  };
  NetNS.prototype._exists = function(cb){
    var netnsExists, table, preRoutingExists, postRoutingExists, tests;
    cb == null && (cb = function(){});
    netnsExists = this._netnsExists();
    table = this._getTable();
    preRoutingExists = this._findRule(table, 'PRE');
    postRoutingExists = this._findRule(table, 'POST');
    if (this.preRouting) {
      tests = [netnsExists, preRoutingExists, postRoutingExists];
    } else {
      tests = [netnsExists, postRoutingExists];
    }
    if (all((function(it){
      return it === true;
    }), tests)) {
      cb(void 8, true);
      return true;
    } else if (any((function(it){
      return it === true;
    }), tests)) {
      cb(void 8, null);
      return null;
    } else if (all((function(it){
      return it === false;
    }), tests)) {
      cb(void 8, false);
      return false;
    } else {
      cb(void 8, null);
      return null;
    }
  };
  NetNS.prototype._netnsExists = function(){
    return fs.existsSync("/var/run/netns/" + this.name);
  };
  NetNS.prototype.test = function(cb){
    var this$ = this;
    this._verified = false;
    return this._exists(function(err, exists){
      var cmd;
      if (err) {
        return cb(err);
      } else if (exists === true) {
        cmd = "ip netns exec " + this$.name + " curl --insecure --max-time 10 --user-agent netns " + _testUrl;
        return child_process.exec(cmd, function(err, stdout, stderr){
          var parsed, that, e;
          console.log(stdout);
          if (err) {
            return cb(stderr);
          } else {
            try {
              parsed = JSON.parse(stdout);
              if (that = (parsed != null ? parsed.ip : void 8) !== this$.ipAddress) {
                return cb(new Error("IP mismatch: got: " + that + " but expected: " + this$.ipAddress));
              } else {
                this$._verified = true;
                return cb(void 8);
              }
            } catch (e$) {
              e = e$;
              return cb(e);
            }
          }
        });
      } else {
        return cb(new Error("namespace doesn't seem to exist"));
      }
    });
  };
  NetNS.prototype.hosts = function(hosts, cb){
    var customHosts, hostsData, dir;
    customHosts = map(function(it){
      return it.join(' ');
    })(
    objToPairs(hosts)).join("\n");
    hostsData = "127.0.0.1 localhost\n" + customHosts;
    dir = "/etc/netns/" + this.name;
    return mkdirp(dir, function(err){
      if (err) {
        return cb(err);
      } else {
        return fs.writeFile(dir + "/hosts", hostsData, function(err){
          if (err) {
            return cb(err);
          } else {
            return cb(void 8);
          }
        });
      }
    });
  };
  NetNS.prototype._getTable = function(){
    return child_process.execSync('iptables -t nat -L -n').toString();
  };
  NetNS.prototype._findRule = function(table, chain){
    var last2Octets;
    last2Octets = this.ipAddress.replace(/^\d+\.\d+\./, '');
    switch (chain) {
    case 'PRE':
      return all((function(it){
        return it !== -1;
      }), [table.indexOf(this.ipAddress), table.indexOf("to:10." + last2Octets + ".1")]);
    case 'POST':
      return all((function(it){
        return it !== -1;
      }), [table.indexOf("10." + last2Octets + ".0/31"), table.indexOf("to:" + this.ipAddress)]);
    default:
      throw new Error('find-rule expects a table and a chain');
    }
  };
  module.exports = NetNS;
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
